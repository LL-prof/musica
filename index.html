<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Music Drag</title>
  <style>
    :root{
      --bg:#10131a;
      --sheet:#ffffff;
      --ink:#0c0f14;
      --shadow: 0 14px 36px rgba(0,0,0,.35);
      --radius:18px;
      --gap:14px;
      --ok:#25c26e;
      --yellow: rgba(180, 140, 0, 0.38);
      --yellowStroke: rgba(130, 95, 0, 0.55);
      --btnBorder: rgba(0,0,0,.18);
      --btnShadow: 0 10px 22px rgba(0,0,0,.14);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 30% 10%, #20283a 0%, var(--bg) 60%, #070a11 100%);
      height:100vh;
      overflow:hidden;
    }
    .wrap{
      height:100vh;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gap);
      padding: 14px;
    }
    .panel{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .content{
      padding: 12px;
      overflow:auto;
      min-height:0;
    }

    /* White sheet */
    .sheet{
      background: var(--sheet);
      border-radius: 16px;
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      border: 1px solid rgba(0,0,0,.08);
      overflow:hidden;
      position:relative;
    }
    .sheetInner{
      padding: 10px 10px 12px 10px;
      position:relative;
    }

    /* Big duration buttons (only allowed text) */
    .durRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      padding: 12px;
    }
    .durBtn{
      height: 64px;
      border-radius: 16px;
      border: 2px solid var(--btnBorder);
      background: #fff;
      box-shadow: var(--btnShadow);
      cursor:pointer;
      user-select:none;
      font-weight: 900;
      letter-spacing: .8px;
      font-size: 18px;
      color: #111;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .durBtn.active{
      border-color: rgba(0,0,0,.55);
      box-shadow: 0 0 0 5px rgba(37,194,110,.18), var(--btnShadow);
    }

    .stage{
      position:relative;
      width:100%;
      max-width: 680px;
      margin: 0 auto;
    }
    svg.staff{
      width:100%;
      height:auto;
      display:block;
    }

    /* Exercises list */
    .exercise{
      margin-bottom: 12px;
    }

    /* Exercise controls: two play buttons, no text */
    .playRow{
      display:flex;
      gap: 12px;
      justify-content:center;
      padding: 12px 12px 0 12px;
    }
    .playBtn{
      width: 74px;
      height: 54px;
      border-radius: 16px;
      border: 2px solid var(--btnBorder);
      background: #fff;
      box-shadow: var(--btnShadow);
      cursor:pointer;
      display:grid;
      place-items:center;
      user-select:none;
    }
    .playBtn svg{ display:block; }
    .playBtn.childOk{
      border-color: rgba(37,194,110,.75);
      box-shadow: 0 0 0 5px rgba(37,194,110,.20), var(--btnShadow);
    }

    /* Pool of draggable notes (no labels) */
    .pool{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      padding: 12px;
      justify-content:center;
    }
    .noteToken{
      width:56px; height:56px;
      border-radius: 999px;
      background: #111;
      color: #fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      user-select:none;
      touch-action:none;
      cursor:grab;
      box-shadow: 0 10px 22px rgba(0,0,0,.18);
      border: 2px solid rgba(255,255,255,.12);
    }
    .noteToken::before{
      content:"‚ô™";
      font-size:22px;
      opacity:.95;
    }
    .noteToken:active{ cursor:grabbing; transform: translateY(1px); }
    .noteToken.locked{
      opacity:.28;
      cursor:default;
      filter: grayscale(.2);
      transform:none;
    }

    /* Green marker appears only after correct placement */
    .okMarker{
      position:absolute;
      width:40px; height:40px;
      border-radius: 12px;
      background: rgba(37,194,110,.18);
      border: 2px solid rgba(37,194,110,.65);
      box-shadow: 0 0 0 4px rgba(37,194,110,.12);
      pointer-events:none;
      transform: translate(-50%, -50%);
    }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .wrap{ grid-template-columns: 1fr; height:auto; overflow:auto; }
    }
  </style>
</head>
<body>

<div class="wrap">

  <!-- LEFT: Reference -->
  <section class="panel">
    <div class="content">
      <div class="sheet">
        <div class="durRow">
          <button class="durBtn active" id="btnNegra">NEGRA</button>
          <button class="durBtn" id="btnBlanca">BLANCA</button>
        </div>
        <div class="sheetInner">
          <div class="stage">
            <svg class="staff" id="refSvg" viewBox="0 0 760 240" role="img" aria-label="Referencia">
              <!-- pentagrama -->
              <g stroke="#111" stroke-width="2">
                <line x1="40" y1="60" x2="720" y2="60" />
                <line x1="40" y1="85" x2="720" y2="85" />
                <line x1="40" y1="110" x2="720" y2="110" />
                <line x1="40" y1="135" x2="720" y2="135" />
                <line x1="40" y1="160" x2="720" y2="160" />
              </g>
              <text x="54" y="130" font-size="52" fill="#111" font-weight="800">ùÑû</text>

              <g id="refHighlight"></g>
              <g id="refNotes"></g>
            </svg>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Exercises -->
  <section class="panel">
    <div class="content" id="exerciseList"></div>
  </section>

</div>

<script>
  // ========= AUDIO (offline) =========
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === "suspended") audioCtx.resume();
  }
  function playTone(freq, ms){
    try{
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = freq;

      const now = audioCtx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.35, now + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + ms/1000);

      o.connect(g);
      g.connect(audioCtx.destination);
      o.start(now);
      o.stop(now + ms/1000 + 0.03);
    }catch(e){}
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  async function playSequence(freqs, noteMs, gapMs){
    for(const f of freqs){
      playTone(f, noteMs);
      await sleep(noteMs + gapMs);
    }
  }

  // ========= SOLFEO MAP =========
  // do4 -> do5 (internally: do5 for the top do)
  const SOL_TO_FREQ = {
    do: 261.63,
    re: 293.66,
    mi: 329.63,
    fa: 349.23,
    sol:392.00,
    la: 440.00,
    si: 493.88,
    do5:523.25
  };
  const SOL_TO_Y = {
    do: 160,
    re: 147.5,
    mi: 135,
    fa: 122.5,
    sol:110,
    la: 97.5,
    si: 85,
    do5:72.5
  };
  const BANDS = [
    {sol:"do",  y:160},
    {sol:"re",  y:147.5},
    {sol:"mi",  y:135},
    {sol:"fa",  y:122.5},
    {sol:"sol", y:110},
    {sol:"la",  y:97.5},
    {sol:"si",  y:85},
    {sol:"do5", y:72.5}
  ];

  // ========= DURATIONS (doubled) =========
  let mode = "negra";
  const NEGRA_MS = 640;   // doubled
  const BLANCA_MS = 2200; // doubled
  function curMs(){ return mode === "negra" ? NEGRA_MS : BLANCA_MS; }

  const btnNegra = document.getElementById("btnNegra");
  const btnBlanca = document.getElementById("btnBlanca");
  btnNegra.addEventListener("pointerdown", () => {
    ensureAudio();
    mode = "negra";
    btnNegra.classList.add("active");
    btnBlanca.classList.remove("active");
    playTone(440, 120);
  });
  btnBlanca.addEventListener("pointerdown", () => {
    ensureAudio();
    mode = "blanca";
    btnBlanca.classList.add("active");
    btnNegra.classList.remove("active");
    playTone(440, 120);
  });

  // ========= SVG NOTE =========
  function svgNote(x, y, clickable, onClick){
    const NS = "http://www.w3.org/2000/svg";
    const g = document.createElementNS(NS, "g");
    g.setAttribute("transform", `translate(${x},${y})`);
    if(clickable){
      g.style.cursor = "pointer";
      g.addEventListener("pointerdown", (e) => { e.preventDefault(); onClick?.(); });
    }
    const head = document.createElementNS(NS, "ellipse");
    head.setAttribute("cx","0"); head.setAttribute("cy","0");
    head.setAttribute("rx","12"); head.setAttribute("ry","9");
    head.setAttribute("fill","#111");
    head.setAttribute("transform","rotate(-18)");

    const stem = document.createElementNS(NS, "line");
    stem.setAttribute("x1","10"); stem.setAttribute("y1","-2");
    stem.setAttribute("x2","10"); stem.setAttribute("y2","-48");
    stem.setAttribute("stroke","#111");
    stem.setAttribute("stroke-width","3");
    stem.setAttribute("stroke-linecap","round");

    g.appendChild(head);
    g.appendChild(stem);
    return g;
  }

  // ========= LEFT: Reference scale (no labels) =========
  const refSvg = document.getElementById("refSvg");
  const refNotesG = document.getElementById("refNotes");
  (function renderReference(){
    const scale = ["do","re","mi","fa","sol","la","si","do5"];
    const startX = 190;
    const stepX  = 70;
    scale.forEach((sol, i) => {
      const x = startX + stepX*i;
      const y = SOL_TO_Y[sol];
      refNotesG.appendChild(svgNote(x, y, true, () => playTone(SOL_TO_FREQ[sol], curMs())));
    });
  })();

  // ========= EXERCISES (soft -> harder) =========
  const EXERCISES = [
    { id:"ex1",  target:["do","do","do"] },
    { id:"ex2",  target:["mi","mi","mi"] },
    { id:"ex3",  target:["re","re","re"] },
    { id:"ex4",  target:["do","mi","do"] },
    { id:"ex5",  target:["do","re","mi"] },
    { id:"ex6",  target:["mi","re","do"] },
    { id:"ex7",  target:["fa","fa","mi"] },
    { id:"ex8",  target:["sol","mi","re"] },
    { id:"ex9",  target:["la","sol","fa"] },
    { id:"ex10", target:["si","la","sol"] },
    { id:"ex11", target:["do5","si","la"] },
    { id:"ex12", target:["do","sol","do5"] }
  ];
  function shuffle(a){
    return a.map(v=>[Math.random(),v]).sort((x,y)=>x[0]-y[0]).map(p=>p[1]);
  }

  function playIcon(){
    return `
      <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M8 5v14l12-7z" fill="#111"></path>
      </svg>
    `;
  }

  // Slots (in viewBox coords) for placing notes left->right
  const SLOT_X = [300, 400, 500];

  // ========= BAND HIGHLIGHT (yellow, inside pentagram only) =========
  // We highlight a "lane" around the nearest band y, clipped to staff bounds (x:40..720, y:60..160).
  function setBandHighlight(svg, yCenter){
    const NS = "http://www.w3.org/2000/svg";
    let g = svg._hlG;
    if(!g){
      g = svg.querySelector(".bandLayer");
      if(!g){
        g = document.createElementNS(NS, "g");
        g.setAttribute("class", "bandLayer");
        // Insert above staff lines but below placed notes
        svg.insertBefore(g, svg.querySelector(".placed") || svg.firstChild);
      }
      svg._hlG = g;
    }
    g.innerHTML = "";
    if(yCenter == null) return;

    // Lane height ~ space between bands
    const laneH = 18; // forgiving, but not huge
    const y = yCenter - laneH/2;

    // Clip inside staff area
    const staffTop = 60, staffBot = 160;
    const yy = Math.max(staffTop, Math.min(y, staffBot - laneH));

    const rect = document.createElementNS(NS, "rect");
    rect.setAttribute("x", "40");
    rect.setAttribute("y", String(yy));
    rect.setAttribute("width", "680"); // 720-40
    rect.setAttribute("height", String(laneH));
    rect.setAttribute("rx", "6");
    rect.setAttribute("fill", "var(--yellow)");
    rect.setAttribute("stroke", "var(--yellowStroke)");
    rect.setAttribute("stroke-width", "1.2");
    g.appendChild(rect);
  }

  function nearestBandFromViewBoxY(vby){
    let best = null, bestD = Infinity;
    for(const b of BANDS){
      const d = Math.abs(b.y - vby);
      if(d < bestD){ bestD = d; best = b; }
    }
    // Tolerance by height in viewBox coords
    return (bestD <= 14) ? best : null;
  }

  // ========= DRAG ENGINE (touch-friendly) =========
  let drag = null;

  function startDrag(e, token, exState){
    if(token.classList.contains("locked")) return;
    ensureAudio();
    token.setPointerCapture(e.pointerId);

    const rect = token.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    const ghost = token.cloneNode(true);
    ghost.style.position = "fixed";
    ghost.style.left = rect.left + "px";
    ghost.style.top = rect.top + "px";
    ghost.style.width = rect.width + "px";
    ghost.style.height = rect.height + "px";
    ghost.style.zIndex = 9999;
    ghost.style.cursor = "grabbing";
    ghost.style.transform = "none";
    document.body.appendChild(ghost);

    drag = { token, ghost, exState, pointerId: e.pointerId, offsetX, offsetY };

    // Optional: quick feedback sound on pick
    playTone(440, 90);

    window.addEventListener("pointermove", onMove, {passive:false});
    window.addEventListener("pointerup", onUp, {passive:false});
  }

  function onMove(e){
    if(!drag || e.pointerId !== drag.pointerId) return;
    e.preventDefault();

    drag.ghost.style.left = (e.clientX - drag.offsetX) + "px";
    drag.ghost.style.top  = (e.clientY - drag.offsetY) + "px";

    // Update yellow band highlight inside THIS exercise staff
    const { exState } = drag;
    updateExerciseBandHighlight(exState, e.clientX, e.clientY);
  }

  function updateExerciseBandHighlight(exState, clientX, clientY){
    const { stage, svg } = exState;
    const r = stage.getBoundingClientRect();
    const inside =
      clientX >= r.left && clientX <= r.right &&
      clientY >= r.top  && clientY <= r.bottom;

    if(!inside){
      setBandHighlight(svg, null);
      exState._hoverBand = null;
      return;
    }

    // Convert clientY to viewBox Y
    const vbH = 240;
    const relY = (clientY - r.top) / r.height;
    const vby = relY * vbH;

    const band = nearestBandFromViewBoxY(vby);
    if(!band){
      setBandHighlight(svg, null);
      exState._hoverBand = null;
      return;
    }
    setBandHighlight(svg, band.y);
    exState._hoverBand = band.sol;
  }

  function onUp(e){
    if(!drag || e.pointerId !== drag.pointerId) return;
    e.preventDefault();

    const { token, ghost, exState } = drag;
    const { stage, svg, target, placed } = exState;

    // Clear highlight
    setBandHighlight(svg, null);

    const stageRect = stage.getBoundingClientRect();
    const ghostRect = ghost.getBoundingClientRect();
    const dropX = ghostRect.left + ghostRect.width/2;
    const dropY = ghostRect.top  + ghostRect.height/2;

    const inside =
      dropX >= stageRect.left && dropX <= stageRect.right &&
      dropY >= stageRect.top  && dropY <= stageRect.bottom;

    let accepted = false;

    if(inside){
      // Determine band by dropY
      const relY = (dropY - stageRect.top) / stageRect.height;
      const vby = relY * 240;
      const band = nearestBandFromViewBoxY(vby);

      if(band){
        const solDragged = token.dataset.sol;
        const nextIndex = placed.findIndex(x => x == null);

        if(nextIndex !== -1){
          const expected = target[nextIndex];

          // Must match: the band (where they dropped) + the dragged note + the expected target at that slot
          if(solDragged === band.sol && solDragged === expected){
            // Place note neatly at slot position
            const x = SLOT_X[nextIndex];
            const y = SOL_TO_Y[solDragged];

            exState.placed[nextIndex] = solDragged;

            // Draw note in SVG
            const placedG = svg.querySelector(".placed");
            placedG.appendChild(svgNote(x, y, false));

            // Green marker at that position
            showMarker(exState, x, y);

            token.classList.add("locked");
            playTone(SOL_TO_FREQ[solDragged], curMs());

            accepted = true;
            updateChildPlayState(exState);
          } else {
            playTone(196.00, 140);
          }
        } else {
          // already full
          playTone(196.00, 90);
        }
      } else {
        playTone(196.00, 90);
      }
    } else {
      playTone(196.00, 70);
    }

    ghost.remove();

    window.removeEventListener("pointermove", onMove);
    window.removeEventListener("pointerup", onUp);
    drag = null;
  }

  function showMarker(exState, vbx, vby){
    // Convert viewBox coords to px within stage
    const r = exState.stage.getBoundingClientRect();
    const px = (vbx / 760) * r.width;
    const py = (vby / 240) * r.height;

    const m = document.createElement("div");
    m.className = "okMarker";
    m.style.left = px + "px";
    m.style.top  = py + "px";
    exState.markerLayer.appendChild(m);
  }

  function updateChildPlayState(exState){
    const childBtn = exState.btnChild;
    const ok =
      exState.placed.every(v => v != null) &&
      exState.placed.join("|") === exState.target.join("|");

    if(ok) childBtn.classList.add("childOk");
    else childBtn.classList.remove("childOk");
  }

  function getChildFreqs(exState){
    return exState.placed
      .filter(v => v != null)
      .map(sol => SOL_TO_FREQ[sol]);
  }
  function getTargetFreqs(exState){
    return exState.target.map(sol => SOL_TO_FREQ[sol]);
  }

  // ========= Build one exercise =========
  function makeExercise(ex){
    const wrapper = document.createElement("div");
    wrapper.className = "exercise";

    const sheet = document.createElement("div");
    sheet.className = "sheet";

    const playRow = document.createElement("div");
    playRow.className = "playRow";

    const btnTarget = document.createElement("button");
    btnTarget.className = "playBtn";
    btnTarget.innerHTML = playIcon();

    const btnChild = document.createElement("button");
    btnChild.className = "playBtn";
    btnChild.innerHTML = playIcon();

    playRow.appendChild(btnTarget);
    playRow.appendChild(btnChild);

    const inner = document.createElement("div");
    inner.className = "sheetInner";

    const stage = document.createElement("div");
    stage.className = "stage";

    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
    svg.setAttribute("class","staff");
    svg.setAttribute("viewBox","0 0 760 240");
    svg.innerHTML = `
      <g stroke="#111" stroke-width="2">
        <line x1="40" y1="60" x2="720" y2="60" />
        <line x1="40" y1="85" x2="720" y2="85" />
        <line x1="40" y1="110" x2="720" y2="110" />
        <line x1="40" y1="135" x2="720" y2="135" />
        <line x1="40" y1="160" x2="720" y2="160" />
      </g>
      <text x="54" y="130" font-size="52" fill="#111" font-weight="800">ùÑû</text>
      <g class="placed"></g>
    `;
    stage.appendChild(svg);

    const markerLayer = document.createElement("div");
    markerLayer.style.position="absolute";
    markerLayer.style.left="0";
    markerLayer.style.top="0";
    markerLayer.style.right="0";
    markerLayer.style.bottom="0";
    markerLayer.style.pointerEvents="none";
    stage.appendChild(markerLayer);

    inner.appendChild(stage);

    // Pool (same notes as target, shuffled)
    const pool = document.createElement("div");
    pool.className = "pool";
    const poolNotes = shuffle(ex.target.slice());
    poolNotes.forEach((sol) => {
      const token = document.createElement("div");
      token.className = "noteToken";
      token.dataset.sol = sol;

      // Tap/click plays the note too
      token.addEventListener("pointerdown", (ev) => {
        // If it's a simple tap without dragging, user might want sound.
        // We'll start drag on same event, but also play quick preview on double-tap.
        // Single tap to preview (very short) can be annoying, so:
        // Use "click" for preview (mouse) + "dblclick" (touch might not have).
      });

      token.addEventListener("click", () => playTone(SOL_TO_FREQ[sol], curMs()));

      pool.appendChild(token);
    });

    // State object
    const exState = {
      id: ex.id,
      target: ex.target.slice(),
      placed: [null, null, null],
      stage,
      svg,
      markerLayer,
      btnTarget,
      btnChild
    };

    // Drag binding
    Array.from(pool.children).forEach(tok => {
      tok.addEventListener("pointerdown", (e) => startDrag(e, tok, exState));
    });

    // Play buttons (always available)
    btnTarget.addEventListener("pointerdown", async () => {
      ensureAudio();
      await playSequence(getTargetFreqs(exState), curMs(), 140);
    });
    btnChild.addEventListener("pointerdown", async () => {
      ensureAudio();
      await playSequence(getChildFreqs(exState), curMs(), 140);
      updateChildPlayState(exState);
    });

    sheet.appendChild(playRow);
    sheet.appendChild(inner);
    sheet.appendChild(pool);
    wrapper.appendChild(sheet);

    return wrapper;
  }

  // ========= Render exercises =========
  (function renderExercises(){
    const list = document.getElementById("exerciseList");
    list.innerHTML = "";
    EXERCISES.forEach(ex => list.appendChild(makeExercise(ex)));
  })();
</script>
</body>
</html>
